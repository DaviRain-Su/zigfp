# Story: v1.3.0 弹性模式

> 实现函数式弹性模式，提供重试、断路器、隔板、超时和降级策略

## 目标

扩展 zigFP 的弹性能力，使应用程序更加健壮：

- 重试策略 - 自动重试失败操作，支持多种退避策略
- 断路器 - 防止级联故障，快速失败
- 隔板模式 - 资源隔离，限制并发
- 超时控制 - 操作超时保护
- 降级策略 - 优雅降级，提供备用方案

## 验收标准

### 重试策略 (retry.zig)

- [x] RetryPolicy 类型 - 重试策略配置
- [x] 固定间隔重试 (fixedDelay)
- [x] 指数退避重试 (exponentialBackoff)
- [x] 带抖动的指数退避 (exponentialBackoffWithJitter)
- [x] 最大重试次数限制
- [x] 可重试错误过滤
- [x] retry 函数 - 执行带重试的操作
- [x] RetryResult - 重试结果（成功/失败/耗尽）
- [x] 单元测试 (16 tests)
- [x] 文档

### 断路器 (circuit_breaker.zig)

- [x] CircuitBreaker 类型 - 断路器状态机
- [x] CircuitState - 状态（Closed/Open/HalfOpen）
- [x] 故障计数和阈值
- [x] 超时后自动恢复（半开状态）
- [x] 成功/失败记录
- [x] execute 函数 - 通过断路器执行操作
- [x] 状态变更回调
- [x] 单元测试 (15 tests)
- [x] 文档

### 隔板模式 (bulkhead.zig)

- [x] Bulkhead 类型 - 并发隔离
- [x] 最大并发数限制
- [x] 等待队列（可选）
- [x] 拒绝策略（快速失败/等待）
- [x] execute 函数 - 在隔板中执行操作
- [x] 资源使用统计
- [x] 单元测试 (14 tests)
- [x] 文档

### 超时控制 (timeout.zig)

- [x] Timeout 类型 - 超时配置
- [x] withTimeout 函数 - 带超时的操作执行
- [x] TimeoutError - 超时错误
- [x] Deadline - 截止时间抽象
- [x] 单元测试 (14 tests)
- [x] 文档

### 降级策略 (fallback.zig)

- [x] Fallback 类型 - 降级策略
- [x] withFallback 函数 - 带降级的操作执行
- [x] 默认值降级
- [x] 备用操作降级
- [x] 缓存降级
- [x] 链式降级
- [x] 单元测试 (15 tests)
- [x] 文档

### 集成

- [x] root.zig 导出新模块
- [x] 更新 CHANGELOG.md
- [x] 所有测试通过 (721 tests)

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成

## 实现详情

### 重试策略 API

```zig
// 创建重试策略
const policy = RetryPolicy.exponentialBackoff(.{
    .initial_delay_ms = 100,
    .max_delay_ms = 5000,
    .multiplier = 2.0,
    .max_retries = 5,
});

// 使用 Builder
var builder = retryPolicy();
const policy = builder
    .withMaxRetries(5)
    .withInitialDelay(100)
    .withJitter(0.1)
    .build();

// 执行带重试的操作
var retrier = Retrier(i32, MyError).init(policy);
const result = try retrier.execute(fetchData, .{url});
```

### 断路器 API

```zig
// 创建断路器
var breaker = CircuitBreaker.init(.{
    .failure_threshold = 5,
    .success_threshold = 3,
    .timeout_ms = 30000,
});

// 使用 Builder
var builder = circuitBreakerBuilder();
var breaker = builder
    .withFailureThreshold(5)
    .withSuccessThreshold(3)
    .withTimeout(30000)
    .build();

// 通过断路器执行操作
const result = breaker.execute(i32, MyError, fetchData, .{url}) catch |err| switch (err) {
    error.CircuitOpen => handleFallback(),
    else => return err,
};
```

### 隔板 API

```zig
// 创建隔板（限制并发为10）
var bh = Bulkhead.init(.{
    .max_concurrent = 10,
    .max_wait_ms = 1000,
    .rejection_policy = .wait,
});

// 在隔板中执行操作
const result = try bh.execute(i32, MyError, processRequest, .{request});

// 检查状态
const available = bh.getAvailablePermits();
const is_full = bh.isFull();
```

### 超时 API

```zig
// 创建超时器
var to = Timeout.ms(5000);  // 5秒超时

// 执行带超时的操作
const result = try to.execute(i32, MyError, slowOperation, .{});

// 使用截止时间
const deadline = Deadline.fromNow(5000);
while (!deadline.isExpired()) {
    // 工作...
}
```

### 降级 API

```zig
// 带默认值降级
const result = withFallbackValue(i32, MyError, fetchData, .{url}, defaultValue);

// 带备用操作降级
const result = try withFallbackFn(i32, MyError, fetchFromPrimary, .{}, fetchFromBackup, .{});

// 尝试或返回 null
const maybe_result = tryOrNull(i32, MyError, fetchData, .{url});

// 使用 Fallback 对象
var fb = Fallback(i32, MyError).withDefault(defaultValue);
const result = fb.executeWithFallback(fetchData, .{url}, fallbackValue);
```

### 组合使用

```zig
// 组合多种弹性模式
var breaker = CircuitBreaker.init(.{ .failure_threshold = 5 });
var bh = Bulkhead.init(.{ .max_concurrent = 10 });
const policy = RetryPolicy.exponentialBackoff(.{ .max_retries = 3 });

// 先隔板，再断路器，最后重试
fn resilientFetch(url: []const u8) !Response {
    return bh.execute(Response, MyError, struct {
        fn call(u: []const u8) !Response {
            return breaker.execute(Response, MyError, struct {
                fn inner(uu: []const u8) !Response {
                    var retrier = Retrier(Response, MyError).init(policy);
                    return retrier.execute(doFetch, .{uu});
                }
            }.inner, .{u});
        }
    }.call, .{url});
}
```

## 测试结果

- Retry 模块: 16 tests passed
- CircuitBreaker 模块: 15 tests passed
- Bulkhead 模块: 14 tests passed
- Timeout 模块: 14 tests passed
- Fallback 模块: 15 tests passed
- 总计: 721 tests passed (新增 74 tests)
