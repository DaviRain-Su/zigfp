# Story: v0.5.0 zigFP 高级抽象扩展

> 实现 Bifunctor、Profunctor、Optics（Prism/Iso）、Stream 和 Zipper

## 目标

添加更高级的函数式编程抽象：
- Bifunctor - 双参数 Functor，可以 map 两个类型参数
- Profunctor - 逆变/协变 Functor，用于函数抽象
- Optics - Lens 的扩展（Prism、Iso、Affine、Optional）
- Stream - 惰性流/无限序列
- Zipper - 可导航的数据结构，支持高效局部更新

## 验收标准

### Bifunctor (bifunctor.zig) ✅

- [x] `Bifunctor` 类型类概念
- [x] `Pair(A, B)` - Pair 的 Bifunctor 实现
- [x] `Either(A, B)` - Either 的 Bifunctor 实现
- [x] `bimap` - 同时 map 两个参数
- [x] `first` - 只 map 第一个参数
- [x] `second` - 只 map 第二个参数
- [x] `mapLeft` / `mapRight` - 别名
- [x] Bifunctor 法则测试
- [x] 单元测试 (23 tests)

### Profunctor (profunctor.zig) ✅

- [x] `Profunctor` 类型类概念
- [x] `FunctionProfunctor` - 函数的 Profunctor 实现
- [x] `dimap` - 同时处理输入（逆变）和输出（协变）
- [x] `lmap` - 只处理输入（逆变）
- [x] `rmap` - 只处理输出（协变）
- [x] `Star(F, A, B)` - Kleisli 风格的 Profunctor
- [x] `Costar(F, A, B)` - Co-Kleisli 风格的 Profunctor
- [x] `StrongProfunctor` - 可与 Pair 工作的 Profunctor
- [x] `ChoiceProfunctor` - 可与 Either 工作的 Profunctor
- [x] Profunctor 法则测试 (identity, composition)
- [x] 单元测试 (23 tests)

### Optics (optics.zig) ✅

- [x] `Iso(S, A)` - 同构，双向无损转换
- [x] `Prism(S, A)` - 部分同构，可能失败的构造/解构
- [x] `Affine(S, A)` - Optional，可能不存在的焦点
- [x] `Lens(S, A)` - 总是可以 get 和 set 的焦点
- [x] `Getter(S, A)` - 只读访问
- [x] `Setter(S, A)` - 只写访问
- [x] `Fold(S, A)` - 多焦点只读
- [x] Optics 组合操作 (compose, asLens, asPrism, asGetter, asAffine)
- [x] 常用 Optics 工具函数 (somePrism, headAffine, identityIso)
- [x] Optics 法则测试 (Iso roundtrip, Lens laws, Prism laws)
- [x] 单元测试 (22 tests)

### Stream (stream.zig) ✅

- [x] `Stream(A)` - 惰性无限流
- [x] `head` / `next` - 访问流元素
- [x] `take` / `drop` - 截取操作
- [x] `MapStream` / `FilterStream` - 转换流
- [x] `zipWith` - 合并两个流
- [x] `iterate` - 从初始值迭代生成
- [x] `repeat` / `cycle` - 重复模式
- [x] `unfold` - 通过展开函数生成
- [x] `scanl` - 累积扫描
- [x] `takeWhile` - 条件截取
- [x] `foldN` / `allN` / `anyN` / `findN` - 有限流操作
- [x] 流构造函数 (iterate, repeat, cycle, range, unfold)
- [x] 单元测试 (19 tests)

### Zipper (zipper.zig) ✅

- [x] `ListZipper(A)` - 列表 Zipper
- [x] `extract` / `focusIndex` / `length` - 访问器
- [x] `moveLeft` / `moveRight` - 移动焦点
- [x] `moveToLeft` / `moveToRight` - 边界移动
- [x] `modify` / `set` - 修改操作
- [x] `insertLeft` / `insertRight` - 插入元素
- [x] `delete` - 删除焦点
- [x] `toSlice` - 转换回切片
- [x] `fromSlice` - 从切片创建
- [x] `BinaryTree(A)` / `TreeZipper(A)` - 树 Zipper（简化版）
- [x] `map` - Functor 操作
- [x] `extend` / `duplicate` - Comonad 操作
- [x] 单元测试 (15 tests)

### 集成

- [x] `root.zig` 导出所有新模块
- [x] ROADMAP.md 更新
- [x] README.md 更新（待更新）
- [x] `zig build test` 通过 (436 tests)
- [x] 无内存泄漏

## 技术说明

### Bifunctor

Bifunctor 是两个类型参数的 Functor：

```zig
// Functor: map :: (A -> B) -> F(A) -> F(B)
// Bifunctor: bimap :: (A -> B) -> (C -> D) -> F(A, C) -> F(B, D)

// Either 的 Bifunctor
const either = Either(i32, []const u8).left(42);
const mapped = either.bimap(
    struct { fn f(x: i32) i64 { return x * 2; } }.f,
    struct { fn g(s: []const u8) usize { return s.len; } }.g
);
```

### Profunctor

Profunctor 是输入逆变、输出协变的 Functor：

```zig
// Profunctor: dimap :: (A -> B) -> (C -> D) -> P(B, C) -> P(A, D)

// 函数是 Profunctor
const f: fn(i32) []const u8 = ...;
const g = dimap(
    struct { fn pre(s: []const u8) i32 { return s.len; } }.pre,  // 前处理
    struct { fn post(s: []const u8) usize { return s.len; } }.post, // 后处理
    f
);
// g: []const u8 -> usize
```

### Optics 层次

```
     Iso
      |
    Prism
      |
   Affine (Optional)
    /   \
 Lens   Prism
   \     /
  Traversal
      |
    Fold
```

### Stream

惰性无限流，按需计算：

```zig
// 自然数流
const nats = Stream(i64).iterate(0, struct {
    fn succ(n: i64) i64 { return n + 1; }
}.succ);

// 取前 10 个
const first10 = try nats.take(allocator, 10);  // [0, 1, 2, ..., 9]

// 斐波那契流
const fibs = Stream.unfold(struct { i64, i64 }, i64, .{ 0, 1 }, struct {
    fn step(state: struct { i64, i64 }) ?struct { i64, struct { i64, i64 } } {
        return .{ state[0], .{ state[1], state[0] + state[1] } };
    }
}.step);
```

### Zipper

Zipper 是带焦点的数据结构，支持高效局部操作：

```zig
// 列表 [1, 2, 3, 4, 5]，焦点在 3
const zipper = ListZipper(i32).fromList(&.{1, 2, 3, 4, 5}, 2);

zipper.focus();      // 3
zipper.left();       // 焦点移到 2
zipper.modify(|x| x * 10);  // 焦点变为 20
zipper.toList();     // [1, 20, 3, 4, 5]
```

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成
