# Story: v2.1.0 类型类工具与实用函数

> 添加 Eq、Ord、Bounded 类型类以及常用实用函数

## 目标

1. 实现 Eq 类型类 - 等价性比较抽象
2. 实现 Ord 类型类 - 排序比较抽象
3. 实现 Bounded 类型类 - 有界类型抽象
4. 添加常用实用函数 - when、unless、guard 等

## 验收标准

### Eq (algebra/eq.zig)

等价性比较类型类。

- [x] `Eq(T)` - 等价性类型类接口
- [x] `eq` - 相等比较
- [x] `neq` - 不等比较
- [x] `eqBy` - 使用函数进行比较
- [x] `allEq` - 检查切片所有元素是否相等
- [x] `elem` - 检查元素是否存在
- [x] `notElem` - 检查元素是否不存在
- [x] `findIndex` - 查找元素索引
- [x] `count` - 计算元素出现次数
- [x] `nub` - 去重
- [x] `nubBy` - 按函数去重
- [x] `group` - 分组相邻相等元素
- [x] 预定义实例 (eqI32, eqString 等)
- [x] 单元测试 (12 tests)

### Ord (algebra/ord.zig)

排序比较类型类。

- [x] `Ordering` - 排序枚举 (lt, eq, gt)
- [x] `Ord(T)` - 排序类型类接口
- [x] `compare` - 比较两个值
- [x] `lt`/`le`/`gt`/`ge` - 比较操作符
- [x] `min`/`max` - 最小/最大值
- [x] `clamp` - 限制值在范围内
- [x] `between` - 检查值是否在范围内
- [x] `ordBy` - 使用函数进行比较
- [x] `reverseOrd` - 反转排序
- [x] `minimum`/`maximum` - 切片最小/最大值
- [x] `minimumBy`/`maximumBy` - 按函数取最值
- [x] `isSorted`/`isSortedDesc` - 检查是否有序
- [x] `sortWith` - 排序切片
- [x] 预定义实例 (ordI32, ordF64 等)
- [x] 单元测试 (14 tests)

### Bounded (algebra/bounded.zig)

有界类型类。

- [x] `Bounded(T)` - 有界类型类接口
- [x] `minBound` - 最小边界
- [x] `maxBound` - 最大边界
- [x] `makeBounded` - 创建自定义边界
- [x] `intBounded` - 整数类型边界
- [x] `rangeSize` - 范围大小
- [x] `inBounds` - 检查是否在边界内
- [x] `clampToBounds` - 限制到边界
- [x] `enumerate` - 枚举所有值
- [x] `succ`/`pred` - 后继/前驱
- [x] `succWrap`/`predWrap` - 循环后继/前驱
- [x] 预定义实例 (boundedU8, boundedBool 等)
- [x] 单元测试 (10 tests)

### 实用函数 (function/utils.zig)

常用函数式编程工具函数。

- [x] `when` - 条件执行（返回 Option）
- [x] `whenLazy` - 惰性条件执行
- [x] `unless` - 否定条件执行
- [x] `guard` - 守卫表达式
- [x] `ifThenElse` - 条件表达式
- [x] `ifThenElseLazy` - 惰性条件表达式
- [x] `applyN` - 应用函数 N 次
- [x] `until` - 重复直到条件满足
- [x] `untilMax` - 带最大次数的重复
- [x] `while_` - 重复直到条件不满足
- [x] `on` - 函数组合工具
- [x] `bool_` - 布尔操作命名空间
- [x] `numeric` - 数值操作命名空间
- [x] `comparing` - 比较操作命名空间
- [x] `always` - 常量函数
- [x] `constFirst`/`constSecond` - 参数选择函数
- [x] 单元测试 (10 tests)

### 集成

- [x] algebra/mod.zig 导出 Eq, Ord, Bounded
- [x] function/mod.zig 导出实用函数
- [x] root.zig 导出所有新类型和函数
- [x] 文档更新 (CHANGELOG.md, ROADMAP.md)
- [x] 所有测试通过 (961 tests)

## 技术说明

### Eq 设计

```zig
pub fn Eq(comptime T: type) type {
    return struct {
        eqFn: *const fn (T, T) bool,
        
        pub fn eq(self: @This(), a: T, b: T) bool {
            return self.eqFn(a, b);
        }
        
        pub fn neq(self: @This(), a: T, b: T) bool {
            return !self.eq(a, b);
        }
    };
}

// 默认实现 - 使用 ==
pub fn defaultEq(comptime T: type) Eq(T) {
    return .{
        .eqFn = &struct {
            fn f(a: T, b: T) bool {
                return a == b;
            }
        }.f,
    };
}
```

### Ord 设计

```zig
pub const Ordering = enum { lt, eq, gt };

pub fn Ord(comptime T: type) type {
    return struct {
        compareFn: *const fn (T, T) Ordering,
        
        pub fn compare(self: @This(), a: T, b: T) Ordering {
            return self.compareFn(a, b);
        }
        
        pub fn lt(self: @This(), a: T, b: T) bool {
            return self.compare(a, b) == .lt;
        }
        
        pub fn min(self: @This(), a: T, b: T) T {
            return if (self.lt(a, b)) a else b;
        }
    };
}
```

### 使用示例

```zig
// Eq 使用
const intEq = defaultEq(i32);
const areEqual = intEq.eq(1, 1);  // true

// Ord 使用
const intOrd = defaultOrd(i32);
const smaller = intOrd.min(5, 3);  // 3
const clamped = intOrd.clamp(10, 0, 5);  // 5

// Bounded 使用
const u8Bounds = boundedU8;
const minVal = u8Bounds.minBound;  // 0
const maxVal = u8Bounds.maxBound;  // 255

// 实用函数
const result = when(i32, x > 0, x * 2);  // Some(x*2) if x > 0
const guarded = guard(isValid(input));   // Some(()) or None
```

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成
