# Story: v0.8.0 并行计算抽象

> 实现并行计算抽象，支持Par Monad和并行Traversable

## 目标

为zigFP添加并行计算能力，通过函数式抽象实现：

- Par Monad - 并行计算的Monad抽象
- 并行Traversable - 并行版本的数据遍历
- 工作窃取调度器（可选）
- 负载均衡策略

## 验收标准

### 顺序计算抽象 (parallel.zig)

- [x] `seqMap` - 顺序映射数组（为未来并行实现预留接口）
- [x] `seqFilter` - 顺序过滤数组（为未来并行实现预留接口）
- [x] `seqReduce` - 顺序规约
- [x] `seqFold` - 顺序折叠（带不同类型累加器）
- [x] `seqZip` - 顺序合并两个数组
- [x] `batchMap` - 批量映射
- [x] `batchReduce` - 批量规约
- [x] 类型安全泛型实现
- [x] 内存安全管理

### Par Monad (parallel.zig) - 顺序实现，预留并行接口

- [x] `Par(A)` - 并行计算的Monad类型（当前顺序实现）
- [x] `pure` - 将值提升到并行上下文
- [x] `map` - 应用函数
- [x] `flatMap` - 绑定操作
- [x] `parSequence` - 执行多个计算
- [x] `parZip` - 组合两个计算
- [ ] 线程池管理（未来实现）
- [ ] 错误传播（未来实现）

### 并行Traversable - 顺序实现，预留并行接口

- [x] `parTraverse` - 遍历数组（当前顺序实现）
- [x] `parSequence` - 序列化
- [x] `parMap` - 映射（当前顺序实现）
- [x] `parFilter` - 过滤（当前顺序实现）
- [x] 工作分割策略（接口预留）
- [x] 结果聚合

### 调度器 - 接口已定义，真正并行执行待未来实现

- [x] `WorkStealingScheduler` - 工作窃取调度器（接口定义，顺序模拟实现）
- [x] `FixedThreadPool` - 固定大小线程池（接口定义，顺序模拟实现）
- [x] 任务队列管理（TaskQueue 实现）
- [x] 负载均衡（LoadBalancer 实现，支持 round_robin/least_tasks/random/affinity）
- [x] 优雅关闭（shutdown/awaitTermination 接口）

> **注意**: 当前实现为顺序执行的模拟版本，保持 API 接口一致。
> 真正的并行执行需要 Zig 线程池支持，将在未来版本实现。

### 集成与测试

- [x] root.zig 导出并行模块
- [x] 性能基准测试
- [x] 内存安全测试
- [ ] 并发正确性测试（需要真正的并行实现 - 留待后续版本）
- [ ] 文档和示例（可选，留待后续版本）

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成（顺序实现，为真正并行预留接口）

## 当前完成情况

已实现：
- 基础顺序计算抽象(seqMap, seqFilter, seqReduce, seqFold, seqZip, seqFlatMap)
- 批处理操作(batchMap, batchReduce, BatchConfig)
- 工作分割策略(SplitStrategy, computeSplits)
- Par Monad 接口（顺序实现）
- 并行 Traversable 接口（顺序实现）
- 调度器接口（FixedThreadPool, WorkStealingScheduler - 顺序模拟）
- 任务管理（Task, TaskStatus, TaskPriority, TaskQueue）
- 负载均衡（LoadBalancer, LoadBalanceStrategy）
- root.zig 导出所有接口

未实现（留待后续版本）：
- 真正的并行执行（需要 Zig 线程池支持）

## 实现说明

当前版本实现了完整的并行计算 API 接口，但底层使用顺序执行。
这种设计允许未来无缝升级到真正的并行实现。真正的并行实现需要：

- Zig 稳定的线程池支持
- 工作窃取的实际线程间通信
- 内存隔离保证

这些功能将在 Zig 线程支持稳定后实现，当前版本提供了完整的 API 和顺序替代方案。

## 技术考虑

### 并行策略

- **任务分割**: 将大任务分解为小任务
- **工作窃取**: 空闲线程从忙碌线程窃取任务
- **负载均衡**: 确保所有线程都有工作
- **缓存友好**: 考虑CPU缓存局部性

### 内存管理

- **无锁数据结构**: 避免锁竞争
- **所有权清晰**: 并行执行期间的所有权规则
- **内存隔离**: 避免数据竞争
- **资源清理**: 确保并行任务完成后正确释放资源

### 错误处理

- **错误传播**: 并行计算中的错误如何处理
- **部分失败**: 某些任务失败时如何处理
- **超时控制**: 防止无限等待
- **取消机制**: 支持取消正在进行的并行计算

### 性能优化

- **避免伪共享**: 确保线程本地数据不共享缓存行
- **批处理**: 将小任务批量处理以减少调度开销
- **自适应**: 根据工作负载调整并行度
- **测量开销**: 跟踪并行化带来的性能收益
