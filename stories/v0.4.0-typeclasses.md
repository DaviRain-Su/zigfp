# Story: v0.4.0 zigFP 类型类抽象

> 实现 Applicative、Traversable、Foldable、Arrow 和 Comonad

## 目标

添加更多函数式编程类型类抽象：
- Applicative Functor - 比 Functor 更强，比 Monad 更弱的抽象
- Traversable - 可遍历结构，支持效果遍历
- Foldable - 可折叠结构，支持归约操作
- Arrow - 计算的抽象，函数的泛化
- Comonad - Monad 的对偶

## 验收标准

### Applicative Functor (applicative.zig)

- [x] `OptionApplicative(A)` - Option 的 Applicative 实现
- [x] `ResultApplicative(A, E)` - Result 的 Applicative 实现
- [x] `ListApplicative(A)` - List 的 Applicative 实现
- [x] `pure` - 将值提升到 Applicative 上下文
- [x] `map` - Functor 操作
- [x] `liftA2` - 提升二元函数
- [x] `liftA3Option` - 提升三元函数到 Option
- [x] `productR` - 序列，保留右边
- [x] `productL` - 序列，保留左边
- [x] `product` - 组合为 tuple
- [x] `sequenceOption` - 序列化 Option 操作
- [x] Applicative 法则测试 (identity, homomorphism)
- [x] 单元测试 (24 tests)

### Traversable (traversable.zig)

- [x] `SliceTraversable(A)` - 切片的 Traversable 实现
- [x] `OptionTraversable(A)` - Option 的 Traversable 实现
- [x] `traverseOption` - 带 Option 效果的遍历
- [x] `sequenceOption` - 翻转 Option 嵌套
- [x] `traverseResult` - 带 Result 效果的遍历
- [x] `sequenceResult` - 翻转 Result 嵌套
- [x] `mapAccumL` / `mapAccumR` - 带累积的映射
- [x] `scanl` / `scanr` - 扫描
- [x] `zipWith` - 带函数的 zip
- [x] `partition` - 分区
- [x] 单元测试 (15 tests)

### Foldable (foldable.zig)

- [x] `SliceFoldable(A)` - 切片的 Foldable 实现
- [x] `NumericFoldable(T)` - 数值的 Foldable 实现
- [x] `OptionFoldable(A)` - Option 的 Foldable 实现
- [x] `foldl` - 左折叠
- [x] `foldr` - 右折叠
- [x] `foldMap` - 映射后折叠
- [x] `fold` - 使用 Monoid 折叠
- [x] `toList` - 转换为列表
- [x] `length` - 计算长度
- [x] `isEmpty` - 是否为空
- [x] `contains` - 是否包含
- [x] `find` - 查找元素
- [x] `any` / `all` - 谓词检查
- [x] `count` - 统计满足条件的元素
- [x] `head` / `last` / `nth` - 访问元素
- [x] `sum` / `product` - 数值聚合
- [x] `maximum` / `minimum` - 极值
- [x] `average` - 平均值
- [x] 单元测试 (24 tests)

### Arrow (arrow.zig)

- [x] `FunctionArrow(A, B)` - 函数 Arrow
- [x] `ComposedArrow` - 组合 Arrow
- [x] `arr` - 将函数提升为 Arrow
- [x] `andThen` (>>>) - Arrow 组合
- [x] `first` - 对 pair 的第一个元素操作
- [x] `second` - 对 pair 的第二个元素操作
- [x] `split` (***) - 并行操作
- [x] `fanout` (&&&) - 扇出
- [x] `Either(A, B)` - Either 类型
- [x] `leftChoice` / `rightChoice` - 选择操作
- [x] `choice` (+++) - 对两个分支操作
- [x] `fanin` (|||) - 合并分支
- [x] `idArrow` / `constArrow` - 恒等和常量 Arrow
- [x] `swap` / `dup` - 交换和复制
- [x] Arrow 法则测试 (identity, associativity)
- [x] 单元测试 (19 tests)

### Comonad (comonad.zig)

- [x] `Identity(A)` - Identity Comonad
- [x] `NonEmpty(A)` - NonEmpty List Comonad
- [x] `Store(S, A)` - Store Comonad
- [x] `Env(E, A)` - Env Comonad (Coreader)
- [x] `Traced(M, A)` - Traced Comonad
- [x] `extract` - 提取值
- [x] `duplicate` - 复制结构
- [x] `extend` / `coflatMap` - 扩展
- [x] `map` - Functor 操作
- [x] Comonad 法则测试 (extract . duplicate = id)
- [x] 单元测试 (23 tests)

### 集成

- [x] `root.zig` 导出所有新模块
- [x] ROADMAP.md 更新
- [x] README.md 更新
- [x] `zig build test` 通过 (334 tests)
- [x] 无内存泄漏

## 技术说明

### Applicative Functor

Applicative 位于 Functor 和 Monad 之间：
- 比 Functor 更强：可以应用包装的函数
- 比 Monad 更弱：不能依赖前一个计算的结果

```zig
const OptInt = OptionApplicative(i32);
const optA = OptInt.pure(10);
const optB = OptInt.pure(20);

// liftA2: 提升二元函数
const result = OptInt.liftA2(i32, i32, struct {
    fn add(a: i32, b: i32) i32 { return a + b; }
}.add, optA, optB);  // Some(30)
```

### Traversable

Traversable 允许遍历结构并收集效果：

```zig
const Trav = SliceTraversable(i32);
const nums = [_]i32{ 1, 2, 3 };

// traverseOption: 如果任何元素返回 None，整体返回 None
const result = try Trav.traverseOption(allocator, &nums, i32, struct {
    fn f(x: i32) Option(i32) {
        return some(i32, x * 2);
    }
}.f);  // Some([2, 4, 6])
```

### Foldable

Foldable 提供折叠操作：

```zig
const FoldInt = SliceFoldable(i32);
const nums = [_]i32{ 1, 2, 3, 4, 5 };

// 左折叠求和
const sum = FoldInt.foldl(i32, &nums, 0, struct {
    fn add(a: i32, b: i32) i32 { return a + b; }
}.add);  // 15

// 数值折叠
const NumInt = NumericFoldable(i32);
const max = NumInt.maximum(&nums);  // 5
```

### Arrow

Arrow 是函数的泛化：

```zig
const double = FunctionArrow(i32, i32).arr(struct {
    fn f(x: i32) i32 { return x * 2; }
}.f);

const addOne = FunctionArrow(i32, i32).arr(struct {
    fn f(x: i32) i32 { return x + 1; }
}.f);

// 组合
const composed = double.andThen(i32, addOne);
composed.run(5);  // 11

// 扇出
const fan = fanout(i32, i32, i32, double, addOne);
fan.run(5);  // (10, 6)
```

### Comonad

Comonad 是 Monad 的对偶：

```zig
// Identity Comonad
const id = Identity(i32).init(42);
id.extract();  // 42
id.extend(i32, struct {
    fn f(w: Identity(i32)) i32 { return w.extract() * 2; }
}.f).extract();  // 84

// Store Comonad
const store = Store(i32, i32).init(struct {
    fn f(pos: i32) i32 { return pos * 2; }
}.f, 5);
store.extract();  // 10
store.seek(10).extract();  // 20
```

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成

## 测试统计

| 模块 | 测试数 |
|------|--------|
| applicative.zig | 24 |
| foldable.zig | 24 |
| traversable.zig | 15 |
| arrow.zig | 19 |
| comonad.zig | 23 |
| **v0.4.0 总计** | **105** |
| **项目总计** | **334** |
