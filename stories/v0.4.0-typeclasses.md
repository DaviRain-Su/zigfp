# Story: v0.4.0 zigFP 类型类抽象

> 实现 Applicative、Traversable、Foldable、Arrow 和 Comonad

## 目标

添加更多函数式编程类型类抽象：
- Applicative Functor - 比 Functor 更强，比 Monad 更弱的抽象
- Traversable - 可遍历结构，支持效果遍历
- Foldable - 可折叠结构，支持归约操作
- Arrow - 计算的抽象，函数的泛化
- Comonad - Monad 的对偶

## 验收标准

### Applicative Functor (applicative.zig)

- [ ] `Applicative(F)` 类型类定义
- [ ] `pure` - 将值提升到 Applicative 上下文
- [ ] `ap` - 应用包装的函数
- [ ] `liftA2` - 提升二元函数
- [ ] `liftA3` - 提升三元函数
- [ ] `sequence` - 序列化 Applicative 操作
- [ ] `traverse` - 遍历并收集结果
- [ ] `*>` / `productR` - 序列，保留右边
- [ ] `<*` / `productL` - 序列，保留左边
- [ ] Option 的 Applicative 实现
- [ ] Result 的 Applicative 实现
- [ ] List 的 Applicative 实现
- [ ] Applicative 法则测试
- [ ] 单元测试

### Traversable (traversable.zig)

- [ ] `Traversable(T)` 类型类定义
- [ ] `traverse` - 带效果的映射
- [ ] `sequence` - 翻转嵌套
- [ ] `mapAccum` - 带累积的映射
- [ ] `scanl` / `scanr` - 扫描
- [ ] Option 的 Traversable 实现
- [ ] List 的 Traversable 实现
- [ ] Traversable 法则测试
- [ ] 单元测试

### Foldable (foldable.zig)

- [ ] `Foldable(F)` 类型类定义
- [ ] `foldl` - 左折叠
- [ ] `foldr` - 右折叠
- [ ] `foldMap` - 映射后折叠
- [ ] `fold` - 使用 Monoid 折叠
- [ ] `toList` - 转换为列表
- [ ] `length` - 计算长度
- [ ] `isEmpty` - 是否为空
- [ ] `contains` - 是否包含
- [ ] `find` - 查找元素
- [ ] `any` / `all` - 谓词检查
- [ ] `sum` / `product` - 数值聚合
- [ ] `maximum` / `minimum` - 极值
- [ ] Option 的 Foldable 实现
- [ ] List 的 Foldable 实现
- [ ] Foldable 法则测试
- [ ] 单元测试

### Arrow (arrow.zig)

- [ ] `Arrow(A)` 类型类定义
- [ ] `arr` - 将函数提升为 Arrow
- [ ] `>>>` / `andThen` - Arrow 组合
- [ ] `first` - 对 pair 的第一个元素操作
- [ ] `second` - 对 pair 的第二个元素操作
- [ ] `***` / `split` - 并行操作
- [ ] `&&&` / `fanout` - 扇出
- [ ] Function Arrow 实现
- [ ] Kleisli Arrow 实现
- [ ] Arrow 法则测试
- [ ] 单元测试

### Comonad (comonad.zig)

- [ ] `Comonad(W)` 类型类定义
- [ ] `extract` - 提取值（Monad.pure 的对偶）
- [ ] `duplicate` - 复制结构（Monad.join 的对偶）
- [ ] `extend` - 扩展（Monad.flatMap 的对偶）
- [ ] `coflatMap` - extend 的别名
- [ ] Identity Comonad 实现
- [ ] NonEmpty Comonad 实现
- [ ] Store Comonad 实现
- [ ] Env Comonad 实现
- [ ] Comonad 法则测试
- [ ] 单元测试

### 文档

- [ ] `docs/applicative.md`
- [ ] `docs/traversable.md`
- [ ] `docs/foldable.md`
- [ ] `docs/arrow.md`
- [ ] `docs/comonad.md`

### 集成

- [ ] `root.zig` 导出所有新模块
- [ ] ROADMAP.md 更新
- [ ] README.md 更新
- [ ] `zig build test` 通过
- [ ] 无内存泄漏

## 技术说明

### Applicative Functor

Applicative 位于 Functor 和 Monad 之间：
- 比 Functor 更强：可以应用包装的函数
- 比 Monad 更弱：不能依赖前一个计算的结果

```zig
// Functor:  (A -> B) -> F(A) -> F(B)
// Applicative: F(A -> B) -> F(A) -> F(B)
// Monad: (A -> F(B)) -> F(A) -> F(B)

// 示例：验证多个字段
const name = validateName(input.name);    // Validation(String)
const age = validateAge(input.age);       // Validation(Int)
const email = validateEmail(input.email); // Validation(String)

// 使用 Applicative 组合
const user = liftA3(User.init, name, age, email);
```

### Traversable

Traversable 允许遍历结构并收集效果：

```zig
// 将 List(Option(A)) 转换为 Option(List(A))
const opts = [_]Option(i32){ some(1), some(2), some(3) };
const result = sequence(opts);  // Option([1, 2, 3])

// 如果有 None，结果为 None
const opts2 = [_]Option(i32){ some(1), none(), some(3) };
const result2 = sequence(opts2);  // None
```

### Foldable

Foldable 提供折叠操作：

```zig
// 使用 Monoid 折叠
const nums = [_]i64{ 1, 2, 3, 4, 5 };
const sum = fold(sumMonoid, nums);  // 15

// 使用自定义折叠
const max = foldl(nums, 0, struct {
    fn f(acc: i64, x: i64) i64 {
        return if (x > acc) x else acc;
    }
}.f);  // 5
```

### Arrow

Arrow 是函数的泛化：

```zig
// 普通函数是 Arrow
const double = arr(struct { fn f(x: i32) i32 { return x * 2; } }.f);
const addOne = arr(struct { fn f(x: i32) i32 { return x + 1; } }.f);

// 组合
const composed = double.andThen(addOne);  // x * 2 + 1

// 并行
const both = double.split(addOne);  // (x * 2, x + 1)
```

### Comonad

Comonad 是 Monad 的对偶：

```zig
// Monad:   pure: A -> M(A),    join: M(M(A)) -> M(A)
// Comonad: extract: W(A) -> A, duplicate: W(A) -> W(W(A))

// 示例：Store Comonad（可用于 spreadsheet 计算）
const store = Store(i32, i32).init(
    struct { fn f(pos: i32) i32 { return pos * 2; } }.f,
    5
);
const value = store.extract();  // 10
```

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: -
- 状态: ⏳ 进行中
