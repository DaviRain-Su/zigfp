# Story: v2.0.0 高级类型与工具

> 添加更多高级函数式类型：Ior、Tuple 工具、自然变换

## 目标

1. 实现 Ior - 带错误累积的包含性或类型（类似 Cats 的 Ior）
2. 实现 Tuple 工具 - Pair、Triple 的函数式操作
3. 添加自然变换工具 - 在不同 Functor 间转换

## 验收标准

### Ior (data/ior.zig)

Ior 是带错误累积的 These，适用于"警告但继续"的场景。

- [x] `Ior(E, A)` - Left E | Right A | Both E A
- [x] `Left`/`Right`/`Both` - 构造函数
- [x] `isLeft`/`isRight`/`isBoth` - 类型检查
- [x] `hasLeft`/`hasRight` - 是否包含值
- [x] `getLeft`/`getRight`/`getBoth` - 访问器
- [x] `leftOr`/`rightOr` - 带默认值的访问
- [x] `map` - 映射成功值
- [x] `mapLeft` - 映射错误
- [x] `bimap` - 双向映射
- [x] `fold` - 折叠
- [x] `toOption`/`toResult`/`toResultStrict` - 类型转换
- [x] `toThese` - 转换为 These
- [x] `swap` - 交换左右
- [x] `fromResult`/`fromThese`/`fromOptions` - 静态构造
- [x] `iorLeft`/`iorRight`/`iorBoth` - 便捷构造函数
- [x] 单元测试 (15 tests)

### Tuple (data/tuple.zig)

函数式编程中的元组工具。

- [x] `Pair(A, B)` - 二元组类型
- [x] `Triple(A, B, C)` - 三元组类型
- [x] `init` - 构造函数
- [x] `first`/`second`/`third` - 访问器
- [x] `swap` - 交换 Pair 的两个元素
- [x] `mapFst`/`mapSnd`/`mapThd` - 单边映射
- [x] `bimap`/`trimap` - 多向映射
- [x] `toArray` - 转换为数组
- [x] `fold` - 折叠
- [x] `toPairFst`/`toPairSnd` - Triple 转 Pair
- [x] `pair`/`triple` - 便捷构造函数
- [x] `dup` - 复制值为 Pair
- [x] `fanout`/`fanout3` - 对同一输入应用多个函数
- [x] `assocL`/`assocR` - 结合律变换
- [x] `pairFromArray`/`tripleFromArray` - 从数组创建
- [x] `uncurryPair` - 反柯里化
- [x] 单元测试 (18 tests)

### Natural Transformation (functor/natural.zig)

自然变换 - Functor 间的态射。

- [x] `optionToResult` - Option -> Result
- [x] `resultToOption` - Result -> Option
- [x] `resultErrToOption` - Result 错误 -> Option
- [x] `optionToSlice` - Option -> 切片
- [x] `sliceHeadOption` - 切片头部 -> Option
- [x] `sliceLastOption` - 切片尾部 -> Option
- [x] `sliceAtOption` - 切片索引 -> Option
- [x] `flattenOption` - 展平嵌套 Option
- [x] `flattenResult` - 展平嵌套 Result
- [x] `safeCast` - 安全类型转换
- [x] `fromNullable`/`toNullable` - 可空值互转
- [x] `composeNat` - 组合两个自然变换
- [x] 单元测试 (11 tests)

### 集成

- [x] data/mod.zig 导出 Ior, Tuple
- [x] functor/mod.zig 导出 Natural
- [x] root.zig 导出所有新类型
- [x] 所有测试通过 (915 tests)

## 技术说明

### Ior 设计

```zig
/// Ior - Inclusive Or with error accumulation
/// 类似 These，但设计用于"警告但继续"的场景
pub fn Ior(comptime E: type, comptime A: type) type {
    return union(enum) {
        left: E,      // 只有错误
        right: A,     // 只有成功
        both: struct { e: E, a: A },  // 警告 + 成功
    };
}
```

### Pair/Triple 设计

```zig
pub fn Pair(comptime A: type, comptime B: type) type {
    return struct {
        fst: A,
        snd: B,

        pub fn swap(self: Self) Pair(B, A) {
            return .{ .fst = self.snd, .snd = self.fst };
        }

        pub fn bimap(self: Self, comptime C: type, comptime D: type, 
                     f: fn(A) C, g: fn(B) D) Pair(C, D) {
            return .{ .fst = f(self.fst), .snd = g(self.snd) };
        }
    };
}
```

### 使用示例

```zig
// Ior - 警告但继续
const ior = Ior([]const u8, i32).Both("warning", 42);
const result = ior.toResult();  // Ok(42), 忽略警告
const strict = ior.toResultStrict();  // Err("warning")

// Pair - 函数式元组
const p = Pair(i32, []const u8).init(42, "hello");
const swapped = p.swap();  // Pair([]const u8, i32)
const mapped = p.bimap(i64, usize, toI64, strLen);

// fanout - 对同一值应用两个函数
const doubled_and_negated = fanout(i32, i32, i32, double, negate, 5);
// 结果: Pair(10, -5)

// Natural transformation
const opt = Option(i32).Some(42);
const result = optionToResult(i32, []const u8, opt, "not found");
```

## 完成状态

- 开始日期: 2026-01-02
- 完成日期: 2026-01-02
- 状态: ✅ 已完成
